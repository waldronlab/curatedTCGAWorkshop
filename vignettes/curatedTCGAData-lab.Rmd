---
title: "curatedTCGAData and TCGAutils"
author: "Marcel Ramos and Levi Waldron"
date: "`r format(Sys.time(), '%B %d, %Y')`"
vignette: >
  %\VignetteIndexEntry{Analysis and Resources of Multi-Assay Experiments}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    number_sections: yes
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  cache = TRUE,
  collapse = TRUE,
  comment = "#>"
)
```

# Instructor names and contact information

* Marcel Ramos^[City University of New York, New York, NY, USA] ^[Roswell Park
Comprehensive Cancer Center, Buffalo, NY] (<marcel.ramos@roswellpark.org>)
* Levi Waldron^[City University of New York, New York, NY, USA]

# Workshop Description

This workshop demonstrates the facilities made available by companion packages,
`curatedTCGAData` and `TCGAutils`, to work with TCGA data. Built using the 
`MultiAssayExperiment` class, these packages make the management of multiple
assays easier and more efficient. The workshop also covers relevant data classes
such as `RaggedExperiment`, `SummarizedExperiment`, and
`RangedSummarizedExperiment`, which provide efficient and powerful
operations for representation of copy number, mutation, variant,
and expression data that are represented by different genomic ranges for each
specimen.

There is a built version of this workshop available at
http://rpubs.com/mramos/curatedTCGAWorkshop. The source is available at
https://github.com/waldronlab/MultiAssayExperimentWorkshop.

Presentation slides are available at the link below:

```{r, eval = FALSE} 
browseURL(
"https://docs.google.com/presentation/d/17NS6BDXh1uZYKlF81rZ_fAeEX9LzB2ruf7lK0AJi6qo/edit?usp=sharing"
)
```

## Pre-requisites

* Basic knowledge of R syntax
* Familiarity with the GRanges and SummarizedExperiment classes
* Familiarity with 'omics data types including copy number and gene expression

## Workshop Participation

Students will have a chance to build a `MultiAssayExperiment` object
from scratch, and will also work with more complex objects provided
by the `curatedTCGAData` package.

## R/Bioconductor packages used

To install the workshop dependencies, assuming you have already
[installed Bioconductor](https://www.bioconductor.org/install):

```{r, eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(
    c("org.Hs.eg.db", "mirbase.db", "EnsDb.Hsapiens.v86")
)

BiocManager::install(
    "waldronlab/MultiAssayExperimentWorkshop",
    dependencies = TRUE
)
```

Note, the first line installs experimental data packages not installed
automatically by BiocManager.

Here is a list of packages required for this workshop:

* [curatedTCGAData](https://bioconductor.org/packages/curatedTCGAData)
* [MultiAssayExperiment](https://bioconductor.org/packages/MultiAssayExperiment)
* [SummarizedExperiment](https://bioconductor.org/packages/SummarizedExperiment)
* [GenomicRanges](https://bioconductor.org/packages/GenomicRanges)
* [RaggedExperiment](https://bioconductor.org/packages/RaggedExperiment)
* [TCGAutils](https://bioconductor.org/packages/TCGAutils)
* [UpSetR](https://bioconductor.org/packages/UpSetR)
* [mirbase.db](https://bioconductor.org/packages/mirbase.db)
* [EnsDb.Hsapiens.v86](https://bioconductor.org/packages/EnsDb.Hsapiens.v86)
* [org.Hs.eg.db](https://bioconductor.org/packages/org.Hs.eg.db)

```{r, eval = FALSE}
library(curatedTCGAData)
library(MultiAssayExperiment)
library(SummarizedExperiment)
library(GenomicRanges)
library(RaggedExperiment)
library(GenomicDataCommons)
library(TCGAutils)
library(UpSetR)
library(mirbase.db)
library(EnsDb.Hsapiens.v86)
library(org.Hs.eg.db)
```

```{r, echo = FALSE}
suppressPackageStartupMessages({
    library(curatedTCGAData)
    library(MultiAssayExperiment)
    library(SummarizedExperiment)
    library(GenomicRanges)
    library(RaggedExperiment)
    library(GenomicDataCommons)
    library(TCGAutils)
    library(UpSetR)
    library(mirbase.db)
    library(EnsDb.Hsapiens.v86)
    library(org.Hs.eg.db)
})
```

## Time outline

1h total

| Activity                            | Time    |
|-------------------------------------|---------|
| Overview of key packages | 30 min |
| curatedTCGAData multi-assay dataset | 15 min |
| TCGAutils functionality | 15 min |


# Workshop goals and objectives

## Learning goals

* identify advantages of providing integrative data in a analysis-ready platform
* gain familiarity with available functionality in TCGAutils for the management
and coordination of TGCA data

## Learning objectives

* use curatedTCGAData to create on-the-fly TCGA MultiAssayExperiment datasets
* create a MultiAssayExperiment for TCGA or other multi'omics data
* explore functionality available in TCGAutils with curatedTCGAData objects

# Overview of key packages

## `curatedTCGAData`

Many tools exist for accessing and downloading The Cancer Genome Atlas (TCGA)
data. These include but are not limited to RTCGAToolbox, GenomicDataCommons,
TCGAbiolinks, cBioPortal, and Broad GDAC Firehose. These tools encompass a
spectrum of strengths in ease-of-use, integration, and completeness of data.
Few tools provide an integrative and user-friendly representation of TCGA data
in a widely used analysis platform such as Bioconductor.

The `curatedTCGAData` experiment data package provides on-the-fly construction
of TCGA datasets for 33 different cancer types. It facilitates access and
integration of TCGA data by providing multi-'omics data objects using the
integrative MultiAssayExperiment data class. Where other platforms provide
fragmented datasets, curatedTCGAData ensures that all data provided is matched
and accounted for within the phenotypic metadata.

## `TCGAutils`

Available operations in TCGAutils and MultiAssayExperiment enable user-friendly
operations for subsetting, separating, converting, and reshaping of sample and
feature TCGA data.

TCGAutils works generally with TCGA data and with curatedTCGAData products. It
provides convenience / helper functions in three major areas:

1) conversion / summarization of row annotations to genomic ranges
2) translation and interpretation of TCGA identifiers
3) identification and separation of samples

To better understand how it all fits together, this schematic shows the
relationship among all as part of the curatedTCGAData pipeline.

```{r, echo = FALSE, fig.cap = "Schematic of curatedTCGAData Pipeline"}
knitr::include_graphics("TCGAMAEPipeline20190204.png")
```

# Major Data Classes

##`(Ranged)SummarizedExperiment`

```{r, echo = FALSE, fig.cap = "A matrix-like container where rows represent features of interest and columns represent samples. The objects contain one or more assays, each represented by a matrix-like object of numeric or other mode."}
knitr::include_graphics("SummarizedExperiment.svg")
```

`SummarizedExperiment` is the most important Bioconductor class for matrix-like
experimental data, including from RNA sequencing and micro array experiments. It
can store multiple experimental data matrices of identical dimensions, with
associated metadata on the rows/genes/transcripts/other measurements
(`rowData`), column/sample phenotype or clinical data (`colData`), and the
overall experiment (`metadata`). The derivative class
`RangedSummarizedExperiment` associates a `GRanges` or `GRangesList` vector with
the rows. These classes supersede the use of `ExpressionSet`. Note that many
other classes for experimental data are actually derived from
`SummarizedExperiment`.

## `RaggedExperiment`

`RaggedExperiment` is a flexible data representation for segmented copy number,
somatic mutations such as represented in `.vcf` files, and other ragged array
schema for genomic location data.  Like the `GRangesList` class from
`GenomicRanges`, `RaggedExperiment` can be used to represent _differing_ genomic
ranges on each of a set of samples. In fact, `RaggedExperiment` contains a
`GRangesList`:

```{r}
showClass("RaggedExperiment")
```

However, `RaggedExperiment` provides a flexible set of _Assay_ methods to
support transformation of such data to matrix format.

```{r, echo=FALSE, fig.cap="RaggedExperiment object schematic. Rows and columns represent genomic ranges and samples, respectively. Assay operations can be performed with (from left to right) compactAssay, qreduceAssay, and sparseAssay.", out.width="\\maxwidth"}
knitr::include_graphics("RaggedExperiment.png")
```

## `MultiAssayExperiment`

`MultiAssayExperiment` is an integrative container for coordinating multi-omics
experiment data on a set of biological specimens. As much as possible, its
methods adopt the same vocabulary as `SummarizedExperiment`. A
`MultiAssayExperiment` can contain any number of assays with different
representations. Assays may be *ID-based*, where measurements are indexed
identifiers of genes, microRNA, proteins, microbes, etc.  Alternatively, assays
may be *range-based*, where measurements correspond to genomic ranges that can
be represented as `GRanges` objects, such as gene expression or copy number.
For ID-based assays, there is no requirement that the same IDs be
present for different experiments.  For range-based assays, there is also
no requirement that the same ranges be present for different experiments;
furthermore, it is possible for different samples within an experiment to be
represented by different ranges.  The following data classes have been tested 
to work as elements of a `MultiAssayExperiment`:

1. `matrix`: the most basic class for ID-based datasets, could be used for
example for gene expression summarized per-gene, microRNA, metabolomics, or
microbiome data.
2. `SummarizedExperiment` and derived methods: described above, could be used 
for miRNA, gene expression, proteomics, or any matrix-like data where
measurements are represented by IDs.
3. `RangedSummarizedExperiment`: described above, could be used
for gene expression, methylation, or other data types referring to genomic
positions.
4. `ExpressionSet`: Another rich representation for ID-based datasets, supported
only for legacy reasons
5. `RaggedExperiment`: described above, for non-rectangular (ragged) ranged-based datasets
such as segmented copy number, where segmentation of
copy number alterations occurs and different genomic locations in each sample.
6. `RangedVcfStack`: For VCF archives broken up by chromosome (see `VcfStack`
class defined in the `GenomicFiles` package)
7. `DelayedMatrix`: An on-disk representation of matrix-like objects for large
datasets. It reduces memory usage and optimizes performance with delayed
operations. This class is part of the `DelayedArray` package.

Note that any data class extending these classes, and in fact any data class
supporting row and column names and subsetting can be used as an element of a
`MultiAssayExperiment`.

```{r, echo = FALSE, fig.cap="MultiAssayExperiment object schematic. colData provides data about the patients, cell lines, or other biological units, with one row per unit and one column per variable. The experiments are a list of assay datasets of arbitrary class.  The sampleMap relates each column (observation) in ExperimentList to exactly one row (biological unit) in colData; however, one row of colData may map to zero, one, or more columns per assay, allowing for missing and replicate assays. sampleMap allows for per-assay sample naming conventions. Metadata can be used to store information in arbitrary format about the MultiAssayExperiment. Green stripes indicate a mapping of one subject to multiple observations across experiments.", out.width="\\maxwidth"}
knitr::include_graphics("MultiAssayExperiment.png")
```


# Working with MultiAssayExperiment

## API cheat sheet

```{r cheatsheet, echo = FALSE, fig.cap = "The MultiAssayExperiment API for construction, access, subsetting, management, and reshaping to formats for application of R/Bioconductor graphics and analysis packages.", out.width="\\maxwidth"}
knitr::include_graphics("MultiAssayExperiment_cheatsheet.png")
```

### Building a MultiAssayExperiment from scratch

To start from scratch building your own MultiAssayExperiment, see the package
[Coordinating Analysis of Multi-Assay Experiments vignette](https://bioconductor.org/packages/release/bioc/vignettes/MultiAssayExperiment/inst/doc/MultiAssayExperiment.html).
The package [cheat sheet](https://bioconductor.org/packages/release/bioc/vignettes/MultiAssayExperiment/inst/doc/MultiAssayExperiment_cheatsheet.pdf) is also helpful.

If anything is unclear, please ask a question at
https://support.bioconductor.org/ or create an issue on the [MultiAssayExperiment issue tracker](https://github.com/waldronlab/MultiAssayExperiment/issues).

# The Cancer Genome Atlas (TCGA) as MultiAssayExperiment objects

Most unrestricted TCGA data are available as MultiAssayExperiment objects from
the `curatedTCGAData` package. This represents a lot of harmonization!

```{r}
library(curatedTCGAData)
curatedTCGAData("ACC")
suppressMessages({
    acc <- curatedTCGAData("ACC",
        assays = c("miRNASeqGene", "RPPAArray", "Mutation", "RNASeq2GeneNorm", "CNVSNP"),
        dry.run = FALSE)
})
acc
```

These objects contain most unrestricted TCGA assay and clinical / pathological
data, as well as material curated from the supplements of published TCGA primary
papers at the end of the colData columns:

```{r}
dim(colData(acc))
tail(colnames(colData(acc)), 10)
```

The `TCGAutils` package provides additional helper functions, see below. 

# Utilities for TCGA

Aside from the available reshaping functions already included in the
`MultiAssayExperiment` package, the `r BiocStyle::Biocpkg("TCGAutils")` package provides additional
helper functions for working with TCGA data.

## "Simplification" of `curatedTCGAData` objects

A number of helper functions are available for managing datasets from
`curatedTCGAData`. These include:

- Conversions of `SummarizedExperiment` to `RangedSummarizedExperiment` based on `TxDb.Hsapiens.UCSC.hg19.knownGene` for:
    - `mirToRanges`: microRNA
    - `symbolsToRanges`: gene symbols 
- `qreduceTCGA`: convert `RaggedExperiment` objects to `RangedSummarizedExperiment` with one row per gene symbol, for:
    - segmented copy number datasets ("CNVSNP" and "CNASNP")
    - somatic mutation datasets ("Mutation"), with a value of 1 for any non-silent mutation and a value of 0 for no mutation or silent mutation

The `simplifyTCGA` function combines all of the above operations to create
a more managable `MultiAssayExperiment` object and using
`RangedSummarizedExperiment` assays where possible.

```{r}
(simpa <- TCGAutils::simplifyTCGA(acc))
```

## What types of samples are in the data?

**Solution**

The `sampleTables` function gives you an overview of samples in each assay:

```{r}
sampleTables(acc)

head(sampleTypes)
```

## Curated molecular subtypes

Is there subtype data available in the `MultiAssayExperiment` obtained from `curatedTCGAData`?

**Solution**

The `getSubtypeMap` function will show actual variable names found in `colData`
that contain subtype information. This can only be obtained from
`MultiAssayExperiment` objects provided by `curatedTCGAData`. 

```{r}
getSubtypeMap(acc)
head(colData(acc)$Histology)
```

## Converting TCGA UUIDs to barcodes and back

`TCGAutils` provides a number of ID translation functions.
These allow the user to translate from either file or case UUIDs to TCGA
barcodes and back. These functions work by querying the Genomic Data Commons API
via the `GenomicDataCommons` package (thanks to Sean Davis). These include: 

* `UUIDtoBarcode()`
* `barcodeToUUID()`
* `UUIDtoUUID()`
* `filenameToBarcode()`

See the `r BiocStyle::Biocpkg("TCGAutils")` help pages for details.

## Other TCGA data types

Helper functions to add TCGA exon files (legacy archive), copy number and 
GISTIC copy number calls to MultiAssayExperiment objects are also available in `r BiocStyle::Biocpkg("TCGAutils")`.

# Plotting, correlation, and other analyses

These provide exercises and solutions using the `miniACC` dataset.

## How many `miniACC` samples have data for each combination of assays?

**Solution**

The built-in `upsetSamples` creates an "upset" Venn diagram to answer this
question:

```{r}
upsetSamples(miniACC)
```

In this dataset only 43 samples have all 5 assays, 32 are missing reverse-phase
protein (RPPAArray), 2 are missing Mutations, 1 is missing gistict, 12 have only
mutations and gistict, etc.

## Kaplan-meier plot stratified by pathology_N_stage

Create a Kaplan-meier plot, using pathology_N_stage as a stratifying variable.

**Solution**

The colData provides clinical data for things like a Kaplan-Meier plot for
overall survival stratified by nodal stage.

```{r}
Surv(miniACC$days_to_death, miniACC$vital_status)
```

And remove any patients missing overall survival information:
```{r}
miniACCsurv <- miniACC[, complete.cases(miniACC$days_to_death, miniACC$vital_status), ]
```

```{r}
fit <- survfit(Surv(days_to_death, vital_status) ~ pathology_N_stage, data = colData(miniACCsurv))
ggsurvplot(fit, data = colData(miniACCsurv), risk.table = TRUE)
```

## Multivariate Cox regression including RNA-seq, copy number, and pathology

Choose the *EZH2* gene for demonstration. This subsetting will drop assays with
no row named EZH2:
```{r}
wideacc = wideFormat(miniACC["EZH2", , ],
    colDataCols=c("vital_status", "days_to_death", "pathology_N_stage"))
wideacc$y = Surv(wideacc$days_to_death, wideacc$vital_status)
head(wideacc)
```

Perform a multivariate Cox regression with *EZH2* copy number (gistict),
log2-transformed *EZH2* expression (RNASeq2GeneNorm), and nodal status
(pathology_N_stage) as predictors:
```{r}
coxph(Surv(days_to_death, vital_status) ~ gistict_EZH2 + log2(RNASeq2GeneNorm_EZH2) + pathology_N_stage,
      data=wideacc)
```

We see that *EZH2* expression is significantly associated with overal survival
(p < 0.001), but *EZH2* copy number and nodal status are not. This analysis
could easily be extended to the whole genome for discovery of prognostic
features by repeated univariate regressions over columns, penalized multivariate
regression, etc.

For further detail, see the main MultiAssayExperiment vignette.

<p style="text-align: right;"> [back to top](#overview-of-key-data-classes) </p>

## Correlation between RNA-seq and copy number

**Part 1**

For all genes where there is both recurrent copy number (gistict assay) and
RNA-seq, calculate the correlation between log2(RNAseq + 1) and copy number.
Create a histogram of these correlations. Compare this with the histogram of
correlations between all *unmatched* gene - copy number pairs.

**Solution**

First, narrow down `miniACC` to only the assays needed:

```{r}
subacc <- miniACC[, , c("RNASeq2GeneNorm", "gistict")]
```

Align the rows and columns, keeping only samples with both assays available:
```{r}
subacc <- intersectColumns(subacc)
subacc <- intersectRows(subacc)
```

Create a list of numeric matrices:
```{r}
subacc.list <- assays(subacc)
```

Log-transform the RNA-seq assay:
```{r}
subacc.list[[1]] <- log2(subacc.list[[1]] + 1)
```

Transpose both, so genes are in columns:
```{r}
subacc.list <- lapply(subacc.list, t)
```

Calculate the correlation between columns in the first matrix and columns in the
second matrix:

```{r}
corres <- cor(subacc.list[[1]], subacc.list[[2]])
```

And finally, create the histograms:
```{r}
hist(diag(corres))
hist(corres[upper.tri(corres)])
```

**Part 2**

For the gene with highest correlation to copy number, make a box plot of log2
expression against copy number.

**Solution**

First, identify the gene with highest correlation between expression and copy
number:
```{r}
which.max(diag(corres))
```

You could now make the plot by taking the EIF4E columns from each element of the
list subacc.list *list* that was extracted from the subacc
*MultiAssayExperiment*, but let's do it by subsetting and extracting from the
*MultiAssayExperiment*:

```{r}
df <- wideFormat(subacc["EIF4E", , ])
head(df)
```

```{r}
boxplot(RNASeq2GeneNorm_EIF4E ~ gistict_EIF4E,
        data=df, varwidth=TRUE,
        xlab="GISTIC Relative Copy Number Call",
        ylab="RNA-seq counts")
```

<p style="text-align: right;"> [back to top](#overview-of-key-data-classes) </p>

## Identifying correlated principal components

Perform Principal Components Analysis of each of the five assays, using samples
available on each assay, log-transforming RNA-seq data first.  Using the first
10 components, calculate Pearson correlation between all scores and plot these
correlations as a heatmap to identify correlated components across assays.

**Solution**

Here's a function to simplify doing the PCAs:
```{r}
getLoadings <- function(x, ncomp=10, dolog=FALSE, center=TRUE, scale.=TRUE){
  if(dolog){
    x <- log2(x + 1)
  }
  pc = prcomp(x, center=center, scale.=scale.)
  return(t(pc$rotation[, 1:10]))
}
```

Although it would be possible to do the following with a loop, the different
data types do require different options for PCA (e.g. mutations are a 0/1 matrix
with 1 meaning there is a somatic mutation, and gistict varies between -2 for
homozygous loss and 2 for a genome doubling, so neither make sense to scale and
center). So it is just as well to do the following one by one, concatenating
each PCA results to the MultiAssayExperiment:

```{r}
miniACC2 <- intersectColumns(miniACC)
miniACC2 <- c(miniACC2, rnaseqPCA=getLoadings(assays(miniACC2)[[1]], dolog=TRUE), mapFrom=1L)
miniACC2 <- c(miniACC2, gistictPCA=getLoadings(assays(miniACC2)[[2]], center=FALSE, scale.=FALSE), mapFrom=2L)
miniACC2 <- c(miniACC2, proteinPCA=getLoadings(assays(miniACC2)[[3]]), mapFrom=3L)
miniACC2 <- c(miniACC2, mutationsPCA=getLoadings(assays(miniACC2)[[4]], center=FALSE, scale.=FALSE), mapFrom=4L)
miniACC2 <- c(miniACC2, miRNAPCA=getLoadings(assays(miniACC2)[[5]]), mapFrom=5L)
```

Now subset to keep *only* the PCA results:
```{r}
miniACC2 <- miniACC2[, , 6:10]
experiments(miniACC2)
```

Note, it would be equally easy (and maybe better) to do PCA on all samples
available for each assay, then do intersectColumns at this point instead.

Now, steps for calculating the correlations and plotting a heatmap:
* Use *wideFormat* to paste these together, which has the nice property of
adding assay names to the column names.
* The first column always contains the sample identifier, so remove it.
* Coerce to a matrix
* Calculate the correlations, and take the absolute value (since signs of
principal components are arbitrary)
* Set the diagonals to NA (each variable has a correlation of 1 to itself).
```{r}
df <- wideFormat(miniACC2)[, -1]
mycors <- cor(as.matrix(df))
mycors <- abs(mycors)
diag(mycors) <- NA
```

To simplify the heatmap, show only components that have at least one correlation
greater than 0.5.
```{r}
has.high.cor <- apply(mycors, 2, max, na.rm=TRUE) > 0.5
mycors <- mycors[has.high.cor, has.high.cor]
pheatmap::pheatmap(mycors)
```

The highest correlation present is between PC2 of the RNA-seq assay, and PC1 of
the protein assay.

<p style="text-align: right;"> [back to top](#overview-of-key-data-classes) </p>

## Annotating with ranges
This section doesn't use the `TCGAutils` shortcuts, and is more generally applicable.

Convert all the `ExperimentList` elements in `miniACC`  to
`RangedSummarizedExperiment` objects.  Then use `rowRanges` to annotate these
objects with genomic ranges. For the microRNA assay, annotate instead with the
genomic coordinates of predicted targets.

**Solution**


The following shortcut function takes a list of human gene symbols and uses
`AnnotationFilter` and `EnsDb.Hsapiens.v86` to look up the ranges, and return
these as a GRangesList which can be used to replace the rowRanges of the
SummarizedExperiment objects:

```{r}
getrr <- function(identifiers, EnsDbFilterFunc=AnnotationFilter::SymbolFilter) {
    edb <- EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86
    afl <- AnnotationFilterList(
        EnsDbFilterFunc(identifiers),
        SeqNameFilter(c(1:21, "X", "Y")),
        TxBiotypeFilter("protein_coding"))
    gr <- genes(edb, filter=afl)
    grl <- split(gr, factor(identifiers))
    grl <- grl[match(identifiers, names(grl))]
    stopifnot(identical(names(grl), identifiers))
    return(grl)
}
```

For example:
```{r}
getrr(rownames(miniACC)[[1]])
```

Use this to set the rowRanges of experiments 1-4 with these GRangesList objects
```{r}
rseACC <- miniACC
withRSE <- c(1:3, 5)
for (i in withRSE){
  rowRanges(rseACC[[i]]) <- getrr(rownames(rseACC[[i]]))
}
```

Note that the class of experiments 1-4 is now `RangedSummarizedExperiment`:
```{r}
experiments(rseACC)
```

With ranged objects in the MultiAssayExperiment, you can then do subsetting by
ranges. For example, select all genes on chromosome 1 for the four
*rangedSummarizedExperiment* objects:
```{r}
rseACC[GRanges(seqnames="1:1-1e9"), , withRSE]
```

*Note about microRNA*: You can set ranges for the microRNA assay according to
the genomic location of those microRNA, or the locations of their predicted
targets, but we don't do it here. Assigning genomic ranges of microRNA targets
would be an easy way to subset them according to their targets.

<p style="text-align: right;"> [back to top](#overview-of-key-data-classes) </p>
